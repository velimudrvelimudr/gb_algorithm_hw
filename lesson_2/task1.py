"""
Написать программу, которая будет складывать, вычитать, умножать или делить два числа. Числа и знак операции вводятся пользователем. После выполнения вычисления программа не завершается, а запрашивает новые 
данные для вычислений. Завершение программы должно выполняться при вводе символа '0' в качестве знака операции. Если пользователь вводит неверный знак (не '0', '+', '-', '*', '/'), программа должна сообщать 
об ошибке и снова запрашивать знак операции. Также она должна сообщать пользователю о невозможности деления на ноль, если он ввел его в качестве делителя.

Алгоритм.

Вообще, наиболее красивый вариант - это запросить в начале цикла знак операции и числа, а затем запустить цепочку условий, где последовательно проверяется соответствие знака операции одному из значений из 
списка "+-*/", с выполнением соответствующего действия в случае истины. В конце проверяем "0", и выходим из цикла, в случае истины. Если же ниодно из вышеупомянутых условий не выполнится, сообщить 
пользователю, что он ошибся с вводом знака и попросить повторить. Цикл уходит на следующую итерацию.
Однако, в реальности у этого алгоритма есть недостаток - Пользователь вынужден вводить все три значения, даже если он ввёл неверный знак операции или 0. Поэтомусначала проверяем знак на "0" и ошибку, и 
только потом запрашиваем числа.

Начало (овал)
Коммент: цикл с постусловием.
Запрос знака операции (параллелограмм)
если знак = "0" (ромб)
то завершить цикл.
иначе если знак неравен ниодному из значений "+-*/" (ромб)
то сообщить о ошибке (параллелограмм) (стрелка к началу цикла)
иначе
Запросить два числа  (a и b) (параллелограмм)
Если знак равен "+" (ромб)
то сложить a и b (прямоугольник) (стрелка к первой строке цикла)
иначе если знак равен "-" (ромб)
то вычесть из a число b (Прямоугольник) (к началу цикла)
иначе если знак равен "*" (ромб)
то перемножить a и b (прямоугольник) (к началу цикла)
иначе если знак равен "/" (ромб)
то если b не равно 0
то поделить a на b (прямоугольник) (к началу цикла)
иначе вывести сообщение об ошибке (параллелограмм) (к началу цикла)
Конец (овал)
"""


while True:
    sign = input("Введите знак операции (+ - * /)\nили 0 для завершения: ")

    if sign == '0':
        print("Завершение работы")
        break

    if sign != '+' and sign != '-' and sign != '*' and sign != '/':
        print(f"Вы ввели неверный знак операции {sign}. Попробуйте ещё раз")
        continue
    
    a = int(input("Введите первое число: "))
    b = int(input("Введите второе число: "))

    if sign == '+':
        print(f"a + b = {a + b}")
        # По идее, тут и далее после принтов должны идти continue, но это избыточно, ибо благодаря предшествующим проверкам и идеальному пользователю в эту цепочку условий попадут только валидные данные. 
        # Т.е. одно и только  одно из условий сработает гарантированно  , после чего цикл итак уйдёт на следующую итерацию. Правда, можно было бы ускорить программу, не заставляя её проверять остальные условия после того, как одно из них сработает. Ну в общем, как есть, так есть...
    if sign == '-':
        print(f"a - b = {a - b}")
    if sign == '*':
        print(f"a * b = {a * b}")
    if sign == '/':
        if b != 0:
            print(f"a / b = {a / b}")
        else:
            print(f"Делить на {b} нельзя.")

