"""
1). Отсортируйте по убыванию методом пузырька одномерный целочисленный массив, заданный случайными числами на промежутке [-100; 100). Выведите на экран исходный и отсортированный массивы.
Примечания:
● алгоритм сортировки должен быть в виде функции, которая принимает на вход массив данных,
● постарайтесь сделать алгоритм умнее, но помните, что у вас должна остаться сортировка пузырьком. Улучшенные версии сортировки, например, расчёской, шейкерная и другие в зачёт не идут.
"""

from  random import randrange

def sort_array(array: list) -> list:
    """ Сортирует массив по убыванию. """

    n = 1
    j = len(array) - 1 # для игнорирования отсортированной части массива.
    flagg = False
    while n < len(array):
        for i in range(j):
            if array[i] < array[i + 1]:
                array[i], array[i + 1] = array[i + 1], array[i]
                flagg = True
        if flagg == False:
            break
        n += 1
        j -= 1
        flagg = False
        # print(array)
    return array

array = [randrange(-100, 101, 1) for i in range(10)]
print(array)
sort_array(array)
print("Итог: ", array)

"""
В алгоритм было внесено два улучшения.
1. На каждом прогоне внутреннего цикла в конец массива падает отсортированный элемент (в данном случае наименьший). Следовательно сравнивать егго с предыдущем на следующем прогоне не имеет смысла. Поэтому на 
каждой итерации внешнего цикла просматриваемый внутренним циклом массив уменьшается на единицу.
2. В среднем для сортировки массива не требуется прогонять его количеству раз, равному его длине. Это требуется лишь в том случае, если массив отсортирован в обратную сторону. Поэтому при помощи переменной 
flagg я проверяю, были ли на очередном прогоне внутреннего цикла перестановки элементов. Если нет, то массив отсортирован и из цикла можно выходить.
Вроде бы пузырёк остался пузырьком... Просто число итераций обоих циклов максимально сокращено.
"""