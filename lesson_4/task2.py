""" Написать два алгоритма нахождения i-го по счёту простого числа. 
Функция нахождения простого числа должна принимать на вход натуральное и возвращать соответствующее простое число. 
Проанализировать скорость и сложность алгоритмов. """

from timeit import timeit
from csv import writer

def ef(n: int) -> list:
    """ Реализация решета эратосфена. Функция принимает правую границу диапазона (n) и возвращает список всех простых чисел от 0 до n. """

    a = [i for i in range(n)]
    a[1] = 0
    m = 2

    while m < n:
        if a[m] != 0:
            j = m + m
            while j < n:
                a[j] = 0
                j += m
        m += 1

    return [i for i in a if i != 0]


def get_prime_ef(n: int) -> int:
    """ Поиск n-го простого числа с использованием решета эратосфена. """
    
    # Вычисление размера диапазона в зависимости от n. формализовать зависимость количества простых чисел от размера диапазона мне так и не удалось. Пытался даже калькулятор функций задействовать... В любом случае, 20-ти хватит для любого простого числа, нахождение которого займёт разумное время.
    range_size = lambda prime_number: prime_number * 20

    return ef(range_size(n))[n - 1]


def get_prime1(n: int) -> int:
    """ Поиск n-го простого числа с использованием списка предшествующих простых чисел для проверки на простоту. """

    prime_list = []
    p = 2

    while len(prime_list) < n:
        for prime in prime_list:
            if p % prime == 0:
                p += 1
                break
        else: # если число прошло проверку на простоту...
            prime_list.append(p)
            p += 1

    return prime_list[-1]


def get_prime2(n: int) -> int:
    """ Поиск n-го простого числа наихудшим алгоритмом. """
    # Даже после того, как количество делителей, проверяющих i на простоту было уменьшено с i - 1 до sqrt(i), алгоритм всё равно при n порядка уже десятков уходил в ускоряющийся рост по времени выполнения.

    p = 0
    i = 2

    while p < n:
        number = 2
        while number < int(i**(1/2) + 1):
            if i % number == 0:
                i += 1
                break
            else:
                number += 1
        else:
            i += 1
            p += 1

    return i - 1


def test_get_prime(n: int) -> tuple:
    """ Тест алгоритмов нахождения n-го простого числа. """

    # Ограничил number, чтобы тестирование продолжалось разумное время.
    nb = 10000
    t_ef = timeit('get_prime_ef(n)', number=nb, globals=globals()|locals())
    t_gp1 = timeit('get_prime1(n)', number=nb, globals=globals()|locals())
    t_gp2 = timeit('get_prime2(n)', number=nb, globals=globals()|locals())

    return (t_ef, t_gp1, t_gp2)

# Производим замеры, записываем результат в файл и выводим в консоль.
if __name__ == '__main__':
    # Делаем 10 измерений с шагом step.
    step = 10
    with open('meas2.csv', 'w', encoding='utf-8', newline = '') as mf:
        w = writer(mf, dialect='excel-tab')
        for i in range(1, 11):
            tgp = test_get_prime(i * step)
            w.writerow([i, *tgp])
            print(*[round(j, 2) for j in tgp], sep='\t')

    print('Готово!')

""" Если для малых n 3-й алгоритм показывает лучший результат, чем 1-й, то уже на n близком к 100 становится заметным, что время выполнения 3-го алгоритма растёт с существенным ускорением. Рост же первых двух с виду линейный.

Игрался с cProfile, но этот инструмент ничего особо интересного мне не показал. Он считает только вызовы функций, а выполнение операторов (сравнение, арифметика) не показывает. Поскольку же, особенно в 1 и 3 алгоритме все операции как раз и производятся операторами, вывод cProfile оказался неинформативен. 

Результаты замеров можно посмотреть в файле meas2.csv. Но, на всякий случай ниже приведу один из них.

	EF	1	2
1	0,47	0,06	0,19
2	1,01	0,19	0,59
3	1,66	0,34	1,09
4	2,15	0,64	1,87
5	2,72	0,90	2,70
6	3,34	1,13	3,56
7	3,86	1,52	4,67
8	4,47	1,95	5,87
9	5,15	2,30	6,86
10	5,66	2,79	8,28

"""
